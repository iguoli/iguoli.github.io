---
title: jq 命令
date: 2022-09-16
modify_date: 2023-08-15
tags: Utils
key: Jq-2022-09-16
---

[`jq`] 程序是一个 **过滤器**：接受输入并产生输出。它有很多内置过滤器用于提取对象的特定字段，将数字转换为字符串或各种其他标准任务。

过滤器可以通过多种方式组合，可以通过管道将一个过滤器的输出传递到另一个过滤器，或者将过滤器的输出收集到一个数组中。

一些过滤器会产生多个结果，例如过滤器会生成其输入数组的所有元素，然后对数组的每个元素运行第二个过滤器。通常，在其他语言中使用循环和迭代完成的事情在 [`jq`] 中只是通过管道将过滤器组合在一起来完成。

[`jq`]: https://stedolan.github.io/jq/manual/

<!--more-->

## Baisc Filters

### 通用对象索引 `.[<string>]`

可以使用 `.["foo"]` 这样的过滤器来检索一个对象的字段。如果字段是个标识符类型的字符串时 (`[a-zA-Z0-0_]`)，可以简写为 `.foo`，称为 **对象标识符索引**。

检索多层字段时的格式为 `.["foo"].["bar"]`，对象标识符索引为 `.foo.bar`，等价于管道格式 `.foo | .bar`。

### 可选对象标识符索引 `.foo?`

与 `.foo` 过滤器作用一样，但在找不到检索字段时不会报错，通常用于递归检索。

### 数组索引 `.[<value>]`

如果索引值不是字符串而是数字，`.[2]` 可用于索引数组，数组索引从 `0` 开始。

### 数组/对象值迭代器 `.[]`

输出对象或数组中的所有值，例如

```sh
echo '{"a": 1, "b": 2, "foo": "bar"}' | jq '.[]'
```

输出为

```txt
1
2
"bar"
```

输出指定对象或数组的所有值

```sh
# 对象
jq '.object_name[]' file.json

# 数组
jq '.array_name[]' file.json
```

### 逗号 `,`

逗号 `,` 用于分隔多个过滤器，每个过滤器单独作用于相同的输入，多个过滤器输出结果会合并到一起。

### 管道 `|`

类似于 UNIX 管道，将上一过滤器的输出结果作为下一过滤器的输入。

## 递归下降 `..`

递归索引所有值。注意不能使用 `..foo` 这种写法，而应当使用 `.. | .foo`。更为常用的格式是 `.. | .foo?`，避免对象或数组中缺失字段 `foo` 而报错。

## [表达式比较][expression_comparisons]

[expression_comparisons]: https://jqlang.github.io/jq/manual/#conditionals-and-comparisons

字符串比较 (`==, !=, >, >=, <, <=`) 按字母顺序进行比较，也适用于时间类字符串


### _==_

```sh
jq 'select(.tagValue == "FALSE")' file.json

jq 'select(.retries == 1)' file.json

jq 'select(.timestamp == "20221201T12:00:00")' file.json
```

### _!=_

```sh
jq 'select(.tagValue != "TRUE")' file.json

jq 'select(.retries != 0)' file.json
```

### _>, >=, <, <=_

```sh
jq 'select(.timestamp >= "20221201T12:00:00")' file.json

jq 'select(.timestamp <= "20221201T12:00:00")' file.json
```

### _contains_

```sh
jq 'select(.foo | contains("bar"))' file.json
```

### _not contains_

```sh
jq 'select(.foo | contains("bar") | not)' file.json
```

### _and_

```sh
jq 'select(.foo=="bar" and (.path|contains("log")|not))' file.json
```

### _type_ of key-value

```sh
jq select(.version | select(type == "String"))' file.json
```

[`type`][type] 函数返回其参数的类型，类型为 `null`, `boolean`, `number`, `string`, `array` 或 `object` 其中之一。

[type]: https://jqlang.github.io/jq/manual/#type

## Cheat Sheet

### 忽略非 json 行

如果程序输出为多行，但不是每行都是 json 格式的字符串（例如有 warning 信息的行），可以通过 `-R` 选项配合 `fromjson` 内建函数进行过滤

> **--raw-input / -R**:
> Don´t  parse the input as JSON. Instead, each line of text is passed to the filter as a string. If combined with --slurp, then the entire input is passed to the filter as a single long string.

```sh
output | jq -R 'fromjson?'
```

`fromjson` 从 1.4 版本开始支持

### 输出 json 结果到一行

> **--compact-output / -c**:
> By default, jq pretty-prints JSON output. Using this option will result in more compact output by instead putting each JSON object on a single line.

```sh
output | jq -c .
```

配合上面的 json 行过滤

>  **--raw-output / -r**:
> With this option, if the filter´s result is a string then it will be written directly to standard output rather than being formatted as a JSON string with quotes. This can be useful for making jq filters talk to non-JSON-based systems.
> 输出的字符串不会带引号

```sh
output | jq -crR 'fromjson?'
```

### 按输入的 Keys 顺序输出 json

```sh
jq --sort-keys . file.json

jq -S . file.json
```

### 列出顶层对象的所有 keys

```sh
jq 'keys' file.json

jq 'keys[]' file.json
jq 'keys | .[]' file.json

# -r means output raw strings, not json text
jq -r 'keys[]' file.json
```

### 递归列出所有对象的 key

```sh
jq -r '.. | if type=="object" then .. | keys[] else empty end' file.json
```

### 递归查找是否存在名为 "foo" 的 key

```sh
# recursive search for keys containing "string" stripping empty results
jq '.. | objects | with_entries(select(.key | contains("foo"))) | select(. != {})'

# same, but output propper array
jq '[ .. | objects | with_entries(select(.key | contains("foo"))) | select(. != {}) ]'
# or
jq 'map( .. | objects | with_entries(select(.key | contains("foo"))) | select(. != {}) )'
```
