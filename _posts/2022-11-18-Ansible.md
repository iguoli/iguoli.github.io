---
title: Ansible 笔记
date: 2022-11-18
modify_date: 2022-11-18
tags: Devops
key: Ansible-2022-11-18
---

## [Ansible: What's the difference between task, role, play and playbook?](https://devops.stackexchange.com/questions/9832/ansible-whats-the-difference-between-task-role-play-and-playbook)

**Playbook** 是 **play** 的列表。顶层的 playbook YAML 里只做两件事：

- 定义 play
- 使用关键字 `import_playbook` 从另一个 playbook YAML 文件导入 plays。

playbook 只能被 `ansible-playbook` 调用。

**Task**，用手册的话说，就是用来调用一个 ansible 模块。但是，task 不知道它应该运行在哪些主机上。

**Play** 用来将任务绑定到要运行的服务器上。这里的重点是强制关键字 `hosts`，它告诉哪些主机受到影响以及如何受到影响。

<!--more-->

因此，playbook 的结构和行为如下：

- Playbook: the highest level, just a list of plays
  - Play: ties tasks to host lists
    - Tasks: definition of a call to a module
    - Besides tasks, a play may have pre-tasks, post-tasks and handlers, which are all task-like, and roles.

**Role** 是封装和共享 Ansible 信息的一种简单方法。在角色的子目录下，可以找到任务、处理程序、文件、模板、变量和默认值，这些都与该特定角色相关。

角色只定义任务，不定义这些任务将运行在哪些主机上，所以必须从 play 中引用角色。

角色还可以声明依赖关系，即在执行当前角色之前先运行其他角色。

查看 [Playbook example](https://www.middlewareinventory.com/blog/ansible-playbook-example/)

### Dry run the playbook without making actual changes

```sh
ansible-playbook -i inventory/hosts playbook.yml --check
```

## [Module](https://docs.ansible.com/ansible/latest/user_guide/modules.html)

> Modules are the main building blocks of Ansible playbooks. Although we do not generally speak of “module plugins”, a module is a type of plugin. For a developer-focused description of the differences between modules and other plugins, see [Modules and plugins: what is the difference?](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html#modules-vs-plugins)

> Modules and plugins: what is the difference?
>
> If you are looking to add functionality to Ansible, you might wonder whether you need a module or a plugin. Here is a quick overview to help you understand what you need:
>
> - Modules are reusable, standalone scripts that can be used by the Ansible API, the ansible command, or the ansible-playbook command. Modules provide a defined interface. Each module accepts arguments and returns information to Ansible by printing a JSON string to stdout before exiting. Modules execute on the target system (usually that means on a remote system) in separate processes. Modules are technically plugins, but for historical reasons we do not usually talk about “module plugins”.
>
> - Plugins extend Ansible’s core functionality and execute on the control node within the /usr/bin/ansible process. Plugins offer options and extensions for the core features of Ansible - transforming data, logging output, connecting to inventory, and more.

### Fully Qualified Connection Name (FQCN)

`Namespace.Collection.Content_Name`, the full definition of a module, plugin or filter.

### Plugin documentation tool

```sh
# List all docs for available plugins (default to "module")
ansible-doc -l

# List all docs for builtin modules
ansible-doc -l ansible.builtin

# List all docs for filter plugins
ansible-doc -l -t filter

# view the doc of file module
ansible-doc ansible.builtin.file
# short format
ansible-doc file
```

## Cheat sheets

```ini
# inventory/hosts file
[controller]
localhost ansible_connection=local

[targets]
fedora-vm ansible_connection=ssh ansible_host=10.211.55.4 ansible_user=parallels
```

### List all ansible variables for a host or group

```sh
ansible -i hosts -m debug -a "var=hostvars[inventory_hostname]" all
```

### 在远程主机执行命令

```sh
ansible <host pattern> -i hosts -m command -a hostname
ansible <host pattern> -i hosts -m shell -a hostname
ansible <host pattern> -i hosts -a hostname
```

在命令行指定主机，而不通过 inventory 文件，注意 `-i` 参数中指定的主机最后要加逗号 `,`。

```sh
# run in local
ansible -i localhost, --connection local -m setup all 

# run in target host
ansible -i target_hostname, --user login_name -m setup all 

# run playbook, requires 'hosts: all' in your playbook
ansible-playbook -i target_hostname, site.yml
```

### Ansible-Vault

#### [加密字符串](https://docs.ansible.com/ansible/latest/vault_guide/vault_encrypting_content.html#encrypting-individual-variables-with-ansible-vault)

[ansible-vault encrypt_string]: https://docs.ansible.com/ansible/latest/cli/ansible-vault.html#ansible-vault-encrypt-string

[ansible-vault encrypt_string] 命令将字符串加密，并格式化为可包含在 playbook、roles 或 variables 文件中的格式。要创建一个加密变量，将以下三个选项传递给 [ansible-vault encrypt_string] 命令：

| 选项           | 值                          | 描述                                           |
| -------------- | --------------------------- | ---------------------------------------------- |
|                | **string_to_encrypt**       | 要加密的字符串                                 |
| **--name**     | **string_name_of_variable** | 字符串名称（变量名称）                         |
| **--vault-id** | **label@password_source**   | 密码来源（提示、文件或脚本，带或不带 vault ID) |

命令格式如下

```sh
ansible-vault encrypt_string '<string_to_encrypt>' --name '<string_name_of_variable>' --vault-id <password_source>
```

例如，加密字符串 'foooodev'，其变量名为 'the_dev_secret'，并且使用 *a_password_file* 中的密码

```sh
ansible-vault encrypt_string 'foooodev' --name 'the_dev_secret' --vault-id a_password_file
```

从 Ansible 2.4 开始，`--vault-id` 可用于指示密码用于哪个 vault ID（'dev'、'prod'、'cloud' 等）以及如何获取密码 (prompt, a file path, etc.)，例如：

```sh
ansible-vault encrypt_string 'foooodev' --name 'the_dev_secret' --vault-id dev@a_password_file
```

默认情况下，vault ID 标签只是一个提示，提醒使用哪个密码来加密变量或文件。Ansible 不会检查加密内容标头中的 vault ID 是否与你提供的 vault ID 匹配，详细内容参阅官方文档 [Enforcing vault ID matching](https://docs.ansible.com/ansible/latest/vault_guide/vault_managing_passwords.html#enforcing-vault-id-matching)

#### [查看加密字符串变量](https://docs.ansible.com/ansible/latest/vault_guide/vault_encrypting_content.html#viewing-encrypted-variables)

假如之前加密的字符串变量存储在了文件 *vars.yml* 中，可以使用下面的命令进行解密，

```sh
ansible localhost -m debug -a "var=the_dev_secret" -e "@vars.yml" --vault-id dev@a_password_file
```

解密 host 变量文件中的加密变量

```sh
ansible -i inventories/staging/hosts -m debug -a 'var=ssh_private_key' --vault-id staging@a_password_file group_vars_file_name 
```
